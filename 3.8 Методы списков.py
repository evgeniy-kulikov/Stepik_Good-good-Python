# 3.8 Методы списков
""""""
"""
**********************************************************************
Метод append
**********************************************************************

L.append(x)
Метод .append обязательно принимает одно значение x 
и добавляет его в качестве нового элемента  в конец списка L. 
Следовательно размер списка увеличивается на одно значение. 
Никакого присвоения в переменную, как в случае со строками, здесь не требуется.
a = [34, 23, 12, 28, 9, 15]
print(a)  # [34, 23, 12, 28, 9, 15]
a.append(1)
print(a)  # [34, 23, 12, 28, 9, 15, 1]

Если вы сделаете присвоение в переменную, то потеряете все значения, которые у вас были в списке.
a = [34, 23, 12, 28, 9, 15]
print(a)  # [34, 23, 12, 28, 9, 15]
a = a.append(1)
print(a)  # None

Метод .append принимает только одно значение: 
это может быть строка, число или даже список, но ни в коем случае больше одного элемента.
a = [34, 23, 12, 28, 9, 15]
print(a)
a.append(1, 2 , 3)
print(a) # ОШИБКА!!! TypeError: list.append() takes exactly one argument (3 given)


**********************************************************************
Метод clear
**********************************************************************
Метод .clear не принимает никаких аргументов и делает список L пустым, удаляет все его элементы.
a = [34, 23, 12, 28, 9, 15]
print(a)  # [34, 23, 12, 28, 9, 15]
a.clear()
print(a)  # [] 


**********************************************************************
Метод copy
**********************************************************************
Метод .copy не принимает аргументов, делает копию списка:
создается совершенно новый объект в памяти, он тоже является списком 
и будет состоять из таких же элементов как и оригинальный список, 
но у нового списка будет другой идентификатор.
Копию списка также можно получить через полный срез.
a = [34, 23, 12, 28, 9, 15]
b = a.copy()
print(a)  # [34, 23, 12, 28, 9, 15]
print(b)  # [34, 23, 12, 28, 9, 15]

a[0] = 3
print(a)  # [3, 23, 12, 28, 9, 15]
print(b)  # [34, 23, 12, 28, 9, 15]

Метод .copy делает поверхностную копию, это значит он не делает копию вложенных списков, если они есть. 
При поверхностном копировании не создаются копии у вложенных объектов, 
поэтому изменения в одной переменной будут влиять и на другие.
a = [34, 23, [12, 28, 9], 15]
b = a.copy()
print(a)  # [34, 23, [12, 28, 9], 15]
print(b)  # [34, 23, [12, 28, 9], 15]

a[0] = 3
a[2][1] = 100
print(a)  # [3, 23, [12, 100, 9], 15]
print(b)  # [34, 23, [12, 100, 9], 15]
Если вы хотите выполнить полную копию, включая все вложенные списки,  вам необходимо делать глубокую копию.


**********************************************************************
Метод count
**********************************************************************
Принимает обязательно один аргумент. 
При помощи метода .count можно посчитать сколько раз встретилось в списке переданное значение.
a = [34, 23, 12, 28, 9, 15, 23, 2, 23]
print(f'23 встречается {a.count(23)} раз')  # 23 встречается 3 раз
print(f'12 встречается {a.count(12)} раз')  # 12 встречается 1 раз
print(f'24 встречается {a.count(24)} раз')  # 24 встречается 0 раз


**********************************************************************
Метод extend
**********************************************************************
L.extend(iterable)
Метод .extend принимает обязательно один аргумент - итерабельную последовательность. 
Итерабельня последовательность состоит из нескольких элементов, 
поэтому списки и строки являются такой последовательностью. 
При помощи метода .extend можно добавить сразу все элементы из итерируемой последовательности в конец списка L. 
Значит метод .extend позволяет добавлять много элементов за один раз, вот его отличие от метода .append
a = [34, 23, 12, 28, 9, 15]
print(a)  # [34, 23, 12, 28, 9, 15]
a.extend([23, 12])
print(a)  # [34, 23, 12, 28, 9, 15, 23, 12]
a.extend('hello')
print(a)  # [34, 23, 12, 28, 9, 15, 23, 12, 'h', 'e', 'l', 'l', 'o']
В метод .extend можно передать список или строку, но нельзя передать число. Получите ошибку



**********************************************************************
Метод index
**********************************************************************
L.index(x, [start [, end]])
Метод .index находит переданный элемент x в списке L и возвращает его индекс. 
Если в списке находится несколько элементов,  равных значению x, 
то будет возвращен индекс первого из них. 
Если список не содержит переданный элемент x, будет вызвано исключение ValueError.  
У метода есть необязательные параметры start и end :
*    Если задан индекс start то первое вхождение значения x будет искаться начиная с индекса start.
*    Если заданы индексы start и end, то первое вхождение значения x 
     будет искаться начиная с индекса start и перед индексом end.  
     Индекс start включается, а индекс end не включается

a = [34, 23, 12, 28, 23, 2, 23]
print(a.index(23))          # 1
print(a.index(12))          # 2
print(a.index(23, 1))       # 1
print(a.index(23, 2))       # 4
print(a.index(23, 2, 5))    # 1



**********************************************************************
Метод insert
**********************************************************************
Метод  .insert имеет следующий формат:

L.insert(index, value)
Метод .insert выполняет вставку нового значения в список на определенную позицию. 
Метод .insert должен принимать два значения: 
index  - индекс куда вставляем новое значение и 
value - что нужно ставить, то есть само значение.

a = [34, 23, 12, 28, 23]
a.insert(1, 99)
print(a)  # [34, 99, 23, 12, 28, 23]



**********************************************************************
Метод pop
**********************************************************************
У него следующий формат вызова:

L.pop([index])	
Метод .pop возвращает значение элемента с индексом index, а также удаляет его из списка L. 
По сути метод выполняет изъятие из списка элемента, стоящего на позиции index
Необязательный аргумент - индекс index по умолчанию равен -1. 
Так что по умолчанию эта операция производит действие с последним элементом последовательности. 
Вы можете передать значение индекса для изъятия элемента
Результат метода .pop можно сохранить в переменную или сразу распечатать на экран.
a = [34, 23, 12, 28, 23]

a.pop()
print(a)  # [34, 23, 12, 28]

b = a.pop()
print(b)  # 28
print(a)  # [34, 23, 12]

print(a.pop())  # 12
print(a)  # [34, 23]

print(a.pop(0))  # 34
print(a)  # [23]

Метод .pop вызывает IndexError, когда передать несуществующий индекс или попытаться извлечь элемент из пустого списка.



**********************************************************************
Метод remove
**********************************************************************
Метод .remove имеет следующий формат:

L.remove(x)
Слово remove переводится как «удалить», но этот метод, в отличие от метода .pop, удаляет по значению. 
Вы должны обязательно передать одно значение x. 
Метод .remove производит удаление первого элемента, значение которого равно x из списка L. 
Длина списка уменьшается на единицу, элементы, стоящие справа от удаленного, смещаются влево на одну позицию.
Если в списке L есть несколько элементов равных значению x, удалиться только первый найденный слева элемент. 
За один вызов метода удаляется один элемент, если нужно удалить несколько элементов, 
нужно несколько раз вызвать метод  .remove
a = [34, 23, 12, 28, 23, 34]
a.remove(34)
print(a)  # [23, 12, 28, 23, 34]
a.remove(34)
print(a)  # [23, 12, 28, 23]

Метод .remove вызывает ValueError, когда значение x не найдено в списке L



**********************************************************************
Метод reverse
**********************************************************************
Метод .reverse имеет следующий формат:

L.reverse()
Метод .reverse  не требует никаких аргументов и выполняет разворот списка - 
располагает элементы в противоположном порядке. 
При повторном вызове список вернётся в изначальное положение.
a = [34, 23, 12, 28, 23]
a.reverse()
print(a)  # [23, 28, 12, 23, 34]
a.reverse()
print(a)  # [34, 23, 12, 28, 23]



**********************************************************************
Метод sort
**********************************************************************
Cамый, наверное, популярный метод списков - это .sort. Он выполняет сортировку. Имеет следующий формат:
L.sort(key=None, reverse=False)
Если не передать никаких аргументов, то по умолчанию сортировка будет выполнена по возрастанию. 
После этого можете вызвать метод .reverse. Список отсортируется по убыванию. 
Если вы сразу хотите его отсортировать по убыванию, 
то вы можете вызвать метод .sort и в нём внутри скобок дополнительно прописать reverse=True.

a = [34, 23, 12, 28, 23]
a.sort()
print(a)  # [12, 23, 23, 28, 34]
a.reverse()
print(a)  # [34, 28, 23, 23, 12]

b = [34, 23, 12, 28, 23]
b.sort(reverse=True)
print(b)  # [34, 28, 23, 23, 12]
"""



#  *   *   *   *   *   TASK    *   *   *   *   *

"""
Вводится строка из целых чисел через пробел.
Если первое число не равно последнему,
то нужно добавить значение True,
а иначе - значение False.
Результирующий список lst вывести на экран командой:
print(*lst)

Input:  8 12 2 -10 6
Output: 8 12 2 -10 6 True
"""
lst = list(map(int, input().split()))
lst.append(lst[0] != lst[-1])
print(*lst)


"""
Имеется список городов:
cities = ["Москва", "Казань", "Ярославль"]
Необходимо вставить во вторую позицию этого списка строку "Ульяновск" и вывести список командой:
print(*cities)

Input:  ["Москва", "Казань", "Ярославль"]
Output: Москва Ульяновск Казань Ярославль
"""
cities = ["Москва", "Казань", "Ярославль"]
cities.insert(1,  "Ульяновск")
print(*cities)


"""
Вводится строка с номером телефона в формате: 
+7(xxx)xxx-xx-xx
Необходимо преобразовать ее в список lst (посимвольно, 
то есть, элементами списка будут являться отдельные символы строки). 
Затем, удалить первый '+', число 7 заменить на 8 и убрать дефисы. 
Отобразить полученный список на экране командой:
print("".join(lst))

Input:  +7(912)123-45-67
Output: 8(912)1234567
"""
s = input()
s = s.replace('-', '', 2).replace('+7', '8')  # сразу создаем новую строку
lst = list(s)
# lst.remove('7')  # или работаем поэлементно со списком
# lst.insert(0, '8')
# lst.remove('+')
# lst.remove('-')
# lst.remove('-')
print("".join(lst))



"""
В одну строчку через пробел вводятся: имя, отчество и фамилия. 
Необходимо представить эти данные в виде новой строки в формате: 
Фамилия И.О. (Например, Сергей Михайлович Балакирев -> Балакирев С.М.)

Input:  Сергей Михайлович Балакирев
Output: Балакирев С.М.
"""
s = list(map(str, input().split()))
s1 = s[0][0] + '.'
s2 = s[1][0] + '.'
s3 = s[2]
print(s3, s1 + s2)


"""
Вводятся целые числа в одну строчку через пробел. 
Необходимо преобразовать их в список lst, затем, удалить последнее значение и
если оно нечетное, то в список (в конец) добавить True, иначе - False. 
Отобразить полученный список на экране командой:
print(*lst)

Input:  8 11 0 3 5 6
Output: 8 11 0 3 5 False
"""
lst = list(map(int, input().split()))

end_el = lst.pop() % 2
print(*lst, end_el != 0)

# Вариант
end_el = lst.pop() % 2
lst.append(bool(end_el))
print(*lst, end_el != 0)


"""
Вводятся оценки студента (числа от 2 до 5) в одну строку через пробел. 
Необходимо определить количество двоек и вывести это значение на экран.

Input:  2 3 5 2 4 2 2 5
Output: 4
"""
lst = list(map(int, input().split()))
cnt = lst.count(2)
print(cnt)



"""
Вводятся названия рек в одну строчку через пробел. 
Необходимо все их отсортировать по именам (по возрастанию) и в отсортированном списке удалить первый элемент. 
Результат отобразить на экране в одну строчку через пробел.

Input:  Лена Обь Волга Дон Енисей
Output: Дон Енисей Лена Обь
"""
lst = list(map(str, input().split()))
lst.sort()
print(*lst[1:])
