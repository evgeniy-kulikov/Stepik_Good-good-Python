#  9.1 Выражения-генераторы
""""""

# круглые скобки - чистый генератор
a = (x**2 for x in range(6))
print(a)

# генератор сам по себе является итератором
print(next(a))
print(next(a))
print(next(a))
print(next(a))
print(next(a))
print(next(a))
# превышение диапазоны вызывает ошибку StopIteration
# print(next(a))

# перебрать элементы генератора можно только 1 раз
gen = (x**2 for x in range(6))
print("Первый вызов генератора gen")
for x in gen:
    print(x)
# если попытаться перебрать второй раз, результата не будет
print("Второй вызов генератора gen")
for x in gen:
    print(x)

# Функции, работающие с итераторами(генераторами):
# list, set, sum, max, min и другие
a1 = (x**2 for x in range(6))
print(list(a1))
a1 = (x**2 for x in range(6))
print(set(a1))
# Генератор можно перебрать только 1 раз
print(set(a1))
print(sum(x ** 2 for x in range(6)))
print(max(x ** 2 for x in range(6)))

# Генераторы, по сравнению с обычными списками, не хранят в памяти сразу все значения
# Они генерируют их по мере необходимости
# Пример - создание списка из триллиона значений невозможно сделать напрямую
# lst = list(range(1000000000000))
# создаем генератор списков такого размера
lst = (x for x in range(1000000000000))
for i in lst:
    print(i, end=" ")
    if i > 50:
        break


# Функция len не работает от генератора
a = (x for x in range(10, 20))
# print(len(a))
# нужно сначала перевести генератор в список
b = list(a)
print(b)
print(len(b))

# при формировании списка генератором не стоит заключать его в скобки
print([(x ** 2 for x in range(10))])
# корректное формирование списка генератором
print([x ** 2 for x in range(10)])

# К генератору нельзя обращаться по индексу
z = (x for x in range(10))
# print(z[0])

# Генератор можно распаковать
gen = (el for el in range(5))
print(*gen)
#  0 1 2 3 4

# Генератор можно выборочно распаковать
gen = (el for el in range(5))
print(*(next(gen) for el in range(3)))
#  0 1 2


#  *   *   *   *   *   TASK    *   *   *   *   *


"""
Запишите выражение для генератора, 
который бы возвращал целые числа от 2 до 10 000 с шагом 1 (то есть, 2, 3, 4, ..., 10 000). 
Присвойте этот генератор переменной gen.
"""
gen = (el for el in range(2, 10001))


"""
На вход программы поступают два целых числа a и b (a < b), записанные в одну строчку через пробел. 
На их основе запишите генератор для формирования КВАДРАТОВ чисел в диапазоне [a; b].
Преобразуйте этот генератор в кортеж чисел (без использования операторов циклов) 
и присвойте эту коллекцию переменной tp.
"""
# ввод значений a и b (переменные a и b не менять!)
a, b = map(int, input().split())

tmp = (el ** 2 for el in range(a, b + 1))
tp = tuple(tmp)


"""
На вход программы поступают два целых числа a и b (a < b), записанные в одну строчку через пробел. 
Определите генератор, который бы выдавал модули целых чисел из диапазона [a; b]. 
В цикле выведите первые пять значений этого генератора. Каждое значение с новой строки. 
"""
a, b = map(int, input().split())
gen = (abs(el) for el in range(a, b + 1))
ls = list(gen)
for el in ls[:5]:
    print(el)


"""
Вводится целое положительное число a. Необходимо определить генератор, 
который бы возвращал модули чисел в диапазоне [-a; a], а затем еще один, 
который бы вычислял кубы чисел (возведение в степень 3), возвращаемых первым генератором.
Вывести в одну строчку через пробел первые четыре значения.
"""
n = int(input())
gen1 = (abs(el) for el in range(-n, n + 1))
gen2 = (el ** 3 for el in gen1)
print(*(next(gen2) for el in range(4)))

# вариант
# ls = list(el for idx, el in enumerate(gen2) if idx < 4)
# for el in ls:
#     print(el, end=' ')


"""
Используя символы малых букв латинского алфавита (строка ascii_lowercase):
запишите генератор, который бы возвращал все сочетания из двух букв латинского алфавита. 
Выведите первые 50 сочетаний на экран в строку через пробел.
Например, первые семь начальных сочетаний имеют вид:
aa ab ac ad ae af ag
"""
from string import ascii_lowercase

# Вариант вложенного цикла для генератора
gen = (i + j for i in ascii_lowercase for j in ascii_lowercase)
a = list(gen)[:50]
print(*a)

# Вариант вложенного цикла для списка
gen = (el for el in ascii_lowercase)
a = list(gen)

c = []
for i in a:
    for j in a:
        c += [i + j]
print(*c[:50])

# Вариант вывода в печать
gen = (i + j for i in ascii_lowercase for j in ascii_lowercase)
for x in range(50):
    print(next(gen), end=" ")



"""
Имеется список из названий городов:
cities = ["Москва", "Ульяновск", "Самара", "Уфа", "Омск", "Тула"]
Необходимо записать генератор, который бы используя этот список, выдавал 1 000 000 наименований городов по циклу. 
То есть, дойдя до конца списка, возвращался в начало и повторял перебор. И так, для выдачи миллиона названий. 
Вывести на экран первые 20 наименований городов с помощью генератора в одну строчку через пробел.
"""
cities = ["Москва", "Ульяновск", "Самара", "Уфа", "Омск", "Тула"]

gen = (cities[i % 6] for i in range(1000000))
print(*(next(gen) for el in range(20)))
"""
Циклический перебор по индексу списка
0 % 6  --> 0
1 % 6  --> 1
2 % 6  --> 2
. . . . 
5 % 6  --> 5
6 % 6  --> 0
7 % 6  --> 1
8 % 6  --> 2
"""


"""
Имеется график функции f(x) = 0.5x^2 - 2. 
Необходимо записать генератор, который бы выдавал значения этой функции 
для аргумента x в диапазоне [a; b] с шагом 0.01. 
Величины a, b вводятся с клавиатуры в одну строчку через пробел как целые числа (a< b). 
Вывести на экран первые 20 значений функции с точностью до сотых, взятых из генератора.
P.S. Значения функции вычислять командой:
f(x) = 0.5 * pow(x, 2) - 2.0
Input:  0 10
Output: -2.0 -2.0 -2.0 -2.0 -2.0 -2.0 -2.0 -2.0 -2.0 -2.0 -2.0 -1.99 -1.99 -1.99 -1.99 -1.99 -1.99 -1.99 -1.98
        -1.98
"""
a, b = map(int, input().split())

gen = (0.5 * pow(x / 100, 2) - 2 for x in range(a * 100, b * 100 + 1))
for x in range(20):
    print(round(next(gen), 2), end=" ")

