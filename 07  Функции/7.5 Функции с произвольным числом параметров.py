# 7.5 Функции с произвольным числом параметров
""""""

"""
Объявите функцию с именем get_even, 
которая принимает произвольное количество чисел в качестве аргументов и 
возвращает список, составленный только из четных переданных значений.
Input:  45 4 8 11 12 0
Output: 4 8 12 0
"""
def get_even(*args):
    ls = [el for el in args if el % 2 == 0]
    return ls


"""
Объявите функцию с именем get_biggest_city, 
которой можно передавать произвольное количество названий городов через аргументы. 
Данная функция должна возвращать название города наибольшей длины. 
Если таких городов несколько, то первый найденный (из наибольших). 
Программу реализовать без использования сортировки.
Input:  Питер Москва Самара Воронеж
Output: Воронеж
"""

def get_biggest_city(*args):
    return max(list(args), key=len)


# Вариант
def get_biggest_city(*args, city = ''):
    for item in args:
        if len(item) > len(city):
            city = item
    return city


"""
Объявите функцию с именем get_data_fig 
для вычисления периметра произвольного N-угольника. 
На вход этой функции передаются N длин сторон через аргументы. 
Дополнительно могут быть указаны именованные аргументы:
    type - булево значение True/False
    color - целое числовое значение
    closed - булево значение True/False
    width - целое значение

Функция должна возвращать в виде кортежа 
периметр многоугольника и указанные значения именованных параметров 
в порядке их перечисления в тексте задания (если они были переданы). 
Если какой-либо параметр отсутствует, его возвращать не нужно (пропустить).
"""


def get_data_fig(*args, **kwargs):
    d_kwargs = {'type': 'ТОЧНО', 'color': 'В', 'closed': 'ПОРЯДКЕ', 'width': 'ПЕРЕЧИСЛЕНИЯ'}
    res = tuple([sum(args)] + [kwargs[i] for i in d_kwargs if i in kwargs])
    return res


def get_data_fig(*args, **kwargs):
    d_kwargs = {'type': None, 'color': None, 'closed': None, 'width': None}
    res = tuple([sum(args)] + [kwargs[i] for i in d_kwargs if i in kwargs])
    return res


# В PyCharm так работает, а в тесте нет. Оказалось, что главное: порядок перечисления аргументов
def get_data_fig(*args, **kwargs):
    per = sum(args)
    return per, *kwargs.values()



"""
Вводится таблица целых чисел (см. пример ниже) размером N x N элементов (N определяется по входным данным). 
Эта таблица содержит нули, но кое-где - единицы. С помощью функции с именем verify, 
на вход которой передается двумерный список чисел, необходимо проверить, 
являются ли единицы изолированными друг от друга, то есть, вокруг каждой единицы должны быть нули.

Рекомендуется следующий алгоритм. 
В функции verify производить перебор двумерного списка. 
Для каждого элемента (списка) со значением 1 вызывать еще одну вспомогательную функцию is_isolate 
для проверки изолированности единицы. 
То есть, функция is_isolate должна возвращать True, 
если единица изолирована и False - в противном случае.

Как только встречается не изолированная единица, 
функция verify должна возвращать False. Если успешно доходим (по элементам списка) до конца, 
то возвращается значение True.

При реализации функции is_isolate не следует прописывать восемь операторов if. 
Input:  
1 0 0 0 0
0 0 1 0 0
0 0 0 0 0
0 1 0 1 0
0 0 0 0 0
Output: True
"""

# ls_in = [[1, 0, 0, 0, 0],
#          [0, 0, 1, 0, 0],
#          [0, 0, 0, 0, 0],
#          [0, 1, 0, 1, 0],
#          [0, 0, 0, 0, 0]]

def is_isolate(ls, row, col):
    if sum(ls[row - 1][col - 1:col + 1] +
           ls[row][col - 1:col + 1] +
           ls[row + 1][col - 1:col + 1]) > 1:
        return False
    return True


def verify(ls: list):
    # расширяем матрицу по контуру нулями
    for row in ls:
        row.insert(0, 0)
        row.append(0)
    ls_null = [0] * (len(ls) + 2)
    ls.insert(0, ls_null)
    ls.append(ls_null)

    for row in range(1, len(ls) - 1):
        for col in range(1, len(ls) - 1):
            if ls[row][col] == 1 and not is_isolate(ls, row, col):
                return False
    return True

# Шикарное решение
def is_isolate(*ls):
    return ls.count(1) < 2


def verify(ls: list):
    for row in range(len(ls) - 1):
        for col in range(len(ls[row]) - 1):
            # с левого верхнего угла матрицы пробегаем проверочной матрицей размером 2 х 2
            if not is_isolate(ls[row][col], ls[row][col + 1], ls[row + 1][col], ls[row + 1][col + 1]):
                return False
    return True


"""
Объявите функцию с именем str_min, 
которая сравнивает две переданные строки и возвращает минимальную из них 
(то есть, выполняется лексикографическое сравнение строк). 
Затем, используя функциональный подход к программированию 
(то есть, более сложные функции реализуются путем вызова более простых), 
реализовать еще две аналогичные функции:
- с именем str_min3 для поиска минимальной строки из трех переданных строк;
- с именем str_min4 для поиска минимальной строки из четырех переданных строк.

FAQ:
Алгоритм сравнения двух строк :
Сначала сравниваются первые символы строк.
Если первый символ первой строки больше (меньше), чем первый символ второй, то первая строка больше (меньше) второй.
Если первые символы равны, то таким же образом сравниваются уже вторые символы строк.
Сравнение продолжается, пока не закончится одна из строк. Если обе строки заканчиваются одновременно, 
и все их соответствующие символы равны между собой, то строки считаются равными. 
Иначе, большей считается более длинная строка.
"""
def str_min(a, b):
    if b < a:
        a, b = b, a
    return a


def str_min3(a, b, c):
    return str_min(a, str_min(b, c))


def str_min4(a, b, c, d):
    return str_min(str_min(a, b), str_min(c, d))

