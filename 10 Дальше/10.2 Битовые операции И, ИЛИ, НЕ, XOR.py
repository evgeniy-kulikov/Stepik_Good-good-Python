#  10.2 Битовые операции И, ИЛИ, НЕ, XOR
""""""

a = 121
bin(a)  # 0b1111001

int('1111001', 2)  # 121

# # # # # # # # #
"""
битовое НЕ (NOT)  (~)

a  ~
0  1
1  0
"""
# первый бит - знаковый
# битовое НЕ - меняет значения всех битов числа на противоположные
b = ~a  # -122
bin(b)  # -0b1111010

d = 0
n = ~d  # -1

d = 10
n = ~d  # -11

d = -10
n = ~d  # 9


# # # # # # # # #
"""
битовая операция И (&)  (побитовое И)

a  b  &
0  0  0
0  1  0
1  0  0
1  1  1
"""
flags = 5  # 00000101
mask = 4   # 00000100
res = flags & mask  # # 00000100    = 4


# используется для проверки включен ли второй бит в переменной flags
if flags & mask == mask:
    print("Включен 2-й бит числа")
else:
    print("Второй бит числа выключен")

# битовое И используется также для выключения определенных бит числа
flags = 13  # 00001101
mask = 5    # 00000101
# flags = flags & ~mask
# альтернативная запись
flags &= ~mask
print(flags)  # 8  # 00001000


# # # # # # # # #
"""
битовая операция ИЛИ  (|)  (OR)

a  b  OR
0  0  0
0  1  1
1  0  1
1  1  1
"""
# применяется, когда нужно включить отдельные биты переменной
flags = 8  # 00001000
mask = 5   # 00000101
# flags = flags | mask
# альтернативная запись
flags |= mask
print(flags)  # 13  # 00001101


# # # # # # # # #
"""
# битовая операция XOR
# исключающее или   (^)  (XOR)


a  b  XOR
0  0  0
0  1  1
1  0  1
1  1  0
"""
# с ее помощью удобно переключать биты
# единица в бите второго оператора переключает биты в первом
flags = 9
mask = 1
flags = flags ^ mask  # 8

# Операция XOR работает без потерь.
# При повторном применении возвращает исходное значение.
# Применяется, например, при шифровании, mask - это пароль
flags ^= mask  # 9


# приоритеты: ~, &, (|, ^)
"""
Полная форма    Краткая форма   Приоритет
a = a & b       a &= b          2 (И)
a = a | b       a |= b          1 (ИЛИ)
a = a ^ b       a ^= b          1 (XOR)
~a                              3 (НЕ)
"""


# смещение бит вправо >>
# смещение бит влево <<

x = 160
bin(x)  # 10100000   ('0b10100000')
# операция сдвига на бит вправо делит число на два
x = x >> 1  # 80
bin(x)  # 1010000   ('0b1010000')
# сдвиг на два бита вправо делит число на 4
x = x >> 2  # 20
bin(x)  # 10100   ('0b10100')


# при сдвиге числа с крайними единицами, правые значения теряются
x = x >> 2  # 5
bin(x)  # 101   ('0b101')
# эквивалент целочисленного деления
x = x >> 1  # 2
bin(x)  # 10   ('0b10')

# сдвиг влево эквивалентен умножению на 2 в соответствующей степени
x = x << 1  # 4
bin(x)  # 100   ('0b100')

x = x << 3  # 32
bin(x)  # 100000   ('0b100000')

# битовые сдвиги работают гораздо быстрее традиционного деления и умножения
# применяются для маломощных и встроенных систем


#
#  *   *   *   *   *   TASK    *   *   *   *   *
#


# 02
"""
На вход программы подается целое десятичное число. 
Используя битовые операции, включите третий бит введенного числа. 
Input:  100
Output: 108
"""
a = int(input())
print(a | 8)
# bin(8)   '0b1000'

# Вариант
a = int(input())
print(a | 0b1000)

# Вариант
a = int(input())
print(a | (1 << 3))


# 03
"""
На вход программы подается целое десятичное число. 
Используя битовые операции, выключите 4-й и 1-й биты введенного числа.  
Input:  153
Output: 137
"""
a = int(input())
print(a & ~0b10010)

# Вариант
a = int(input())
print(a & ~18)
# bin(18)   '0b10010'

# Вариант
a = int(input())
print(a & ~(1 << 4) & ~(1 << 1))


# 04
"""
На вход программы подается целое десятичное число. 
Используя битовые операции, переключите 3-й и 0-й биты введенного числа.
Input:  58
Output: 51
"""
a = int(input())
print(a ^ 0b1001)

a = int(input())
print(a ^ 9)
# bin(9)   '0b1001'

# Вариант
a = int(input())
print(a ^ (1 << 3) ^ (1 << 0))


# 05
"""
На вход программы подается целое десятичное число. 
Используя битовые операции, выполните умножение введенного числа на 4. 
Input:  40
Output: 160
"""
a = int(input())
print(a << 2)


# 06
"""
На вход программы подается целое десятичное число. 
Используя битовые операции, выполните целочисленное деление введенного числа на 2.
Input:  22
Output: 11
"""
a = int(input())
print(a >> 1)


# 07
"""
Вводится зашифрованное слово. 
Шифрование кодов символов этого слова было проведено с помощью битовой операции XOR с ключом key=123. 
То есть, каждый символ был преобразован по алгоритму:
x = ord(x) ^ key
Здесь ord - функция, возвращающая код символа x. 
Расшифруйте введенное слово и выведите его на экран.
Input:  ѩкю[щюлцхZ
Output: Все верно!
"""

st_in = input()
key = 123
for el in st_in:
    print(chr(ord(el) ^ key), end='')


# Вариант
st_in = input()
key = 123
print(*map(lambda el: chr(ord(el) ^ key), st_in), sep='')


# 08
"""
На вход программы подается целое десятичное число. 
Используя битовые операции, проверьте, включен ли 6-й и 3-й биты введенного числа. 
Если они оба включены, то выведите слово ДА, иначе - слово НЕТ.
Input:  106
Output: ДА
"""

n = int(input())
mask = 0b_0100_1000  # 72   0b1001000
print(('НЕТ', "ДА")[n & mask == mask])

# Вариант
n = int(input())
if n & (1 << 3) and n & (1 << 6):
    print('ДА')
else:
    print('НЕТ')


# 09
"""
На вход программы подается целое десятичное число. 
Используя битовые операции, проверьте, включен ли 5-й или 1-й биты введенного числа. 
Если включен хотя бы один из этих битов, то выведите слово ДА, иначе - слово НЕТ.
Input:  74
Output: ДА
"""

n = int(input())
# mask = 0b_0010_0010  # 34   0b00100010
mask1 = 0b_0000_0010
mask2 = 0b_0010_0000
if n & mask1 == mask1 or n & mask2 == mask2:
    print('ДА')
else:
    print('НЕТ')


# Красиво - умно
n = int(input())
mask = 0b_0010_0010  # 34   0b00100010
print("ДА" if n & mask else "НЕТ")
"""
Пояснение:
Если и 5й и 1й бит выключены, то n & mask выдаст 0b_0000_0000  --> bool(0b_0000_0000) == False
Любой включенный требуемый бит для n & mask  даст число отличное от нуля (например  bool(0b_0000_0010) == True)
"""


# Вариант
n = int(input())
if n & (1 << 1) or n & (1 << 5):
    print('ДА')
else:
    print('НЕТ')

